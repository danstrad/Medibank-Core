package med.infographic {	import com.greensock.easing.Quad;	import com.greensock.TweenMax;	import flash.display.BlendMode;	import flash.display.Graphics;	import flash.display.Shape;	import flash.display.Sprite;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	public class Clock extends _Clock {				public var color:uint;				public var text:String;		public var value:Number;				protected var textMask:Sprite;		protected var clock:Sprite;		protected var centreCircle:Sprite;		protected var spokes:Vector.<Shape>;		protected var startHand:Sprite;		protected var endHand:Sprite;				protected var animatingOut:Boolean;				protected var animateTime:Number;		protected static const ANIMATE_TIME:Number = 300;				static public const SPOKE_LENGTH:Number = 126;						public function Clock(text:String, textColor:uint) {			value = 0;						var tf:TextField = textContainer.textField;			tf.wordWrap = false;			tf.autoSize = TextFieldAutoSize.CENTER;			tf.text = text;			tf.textColor = textColor;						clock = new Sprite();			addChild(clock);						textMask = new Sprite();			clock.addChild(textMask);			textContainer.mask = textMask;						var g:Graphics;			spokes = new Vector.<Shape>();			for (var i:int = 0; i < 12; i++) {				var spoke:Shape = new Shape();				g = spoke.graphics;				g.beginFill(0xFFFFFF);				g.drawRect( -1.5, -SPOKE_LENGTH, 3, 18);				g.endFill();				spoke.rotation = i * 360 / 12;				spoke.scaleY = 0;				addChild(spoke);				spokes.push(spoke);			}						startHand = new Sprite();			endHand = new Sprite();			for each(var hand:Sprite in [startHand, endHand]) {				var HAND_RAD:Number = 6;				var HAND_LEN:Number = 96;				var arm:Shape = new Shape();				g = arm.graphics;				g.beginFill(0xFFFFFF);				g.drawCircle(HAND_LEN - HAND_RAD, 0, HAND_RAD);				g.endFill();				hand.addChild(arm);				var circle:Shape = new Shape();				g = circle.graphics;				g.beginFill(0xFFFFFF);				g.drawRect(0, -HAND_RAD, HAND_LEN - HAND_RAD, HAND_RAD * 2);				g.endFill();				hand.addChild(circle);				clock.addChild(hand);				hand.scaleX = 0;				hand.rotation = -90;			}						centreCircle = new Sprite();			var s:Shape = new Shape();			g = s.graphics;			g.beginFill(0xFFFFFF);			g.drawCircle(0, 0, 15);// 22);			g.endFill();						clock.addChild(centreCircle);			centreCircle.addChild(s);						centreCircle.scaleX = centreCircle.scaleY = 0;					}				public function animateOn():void {			drawValue(0);						var hands:Array = [startHand, endHand];			var hand:Sprite;			var t:Number = 0.3;			TweenMax.to(centreCircle, 0.2, { scaleX:1.1, scaleY:1.1, delay:t, ease:Quad.easeOut } );			TweenMax.to(centreCircle, 0.02, { scaleX:1, scaleY:1, delay:t + 0.2, ease:Quad.easeIn } );			t += 0.3;			for each(var spoke:Shape in spokes) {				TweenMax.to(spoke, 0.15, { scaleX:1.05, scaleY:1.05, delay:t, ease:Quad.easeOut } );				TweenMax.to(spoke, 0.015, { scaleX:1, scaleY:1, delay:t + 0.15, ease:Quad.easeIn } );			}			t += 0.2;			for each(hand in hands) {				TweenMax.to(hand, 0.25, { scaleX:1.05, scaleY:1.05, delay:t, ease:Quad.easeOut } );				TweenMax.to(hand, 0.025, { scaleX:1, scaleY:1, delay:t + 0.25, ease:Quad.easeIn } );			}			t += 0.2;						TweenMax.to(this, t, { onComplete:unMask} );						textContainer.rotation = -90;			//TweenMax.to(textContainer, (ANIMATE_TIME * 0.5) / 1000, { rotation:0, delay:t + (ANIMATE_TIME * 0.1) / 1000, ease:Quad.easeOut } );						t += ANIMATE_TIME / 1000;			t += 0.3;			for each(hand in hands) {				TweenMax.to(hand, 0.25, { scaleX:0, scaleY:0, delay:t, ease:Quad.easeIn } );			}			t += 0.3;			TweenMax.to(centreCircle, 0.2, { scaleX:0, scaleY:0, delay:t, ease:Quad.easeIn } );		}				protected function unMask():void {			animatingOut = true;			animateTime = 0;		}				public function animateOff():void {			retract();		}				protected function retract():void {						var t:Number = 0;						TweenMax.to(textContainer, 0.4, { alpha:0, delay:t, ease:Quad.easeIn } );			for each(var spoke:Shape in spokes) {				var a:Number = (spoke.rotation - 90) * Math.PI / 180;				var spokeX:Number = Math.cos(a) * SPOKE_LENGTH * 1.2;				var spokeY:Number = Math.sin(a) * SPOKE_LENGTH * 1.2;				TweenMax.to(spoke, 0.15, { x:spokeX, y:spokeY, scaleX:0, scaleY:0, delay:0.2, ease:Quad.easeIn } );			}					}				public function animate(dTime:Number):void {			if (animatingOut) {				animateTime = Math.min(animateTime + dTime, ANIMATE_TIME);				value = (animateTime / ANIMATE_TIME) * 12;				drawValue(value);								textContainer.rotation = -90 + 360 * Math.min(0.25, (value / 12));								animatingOut = (animateTime < ANIMATE_TIME);			}		}						protected function drawValue(v:Number):void {			var a:Number = (v / 12) * (Math.PI * 2);			var g:Graphics = textMask.graphics;			g.clear();			g.beginFill(color);			g.moveTo(0, 0);			const R:Number = 90;						for (var f:Number = 0; f < a; f += Math.PI / 360) {				var angle:Number = -Math.PI / 2 + f;				g.lineTo(Math.cos(angle) * R, Math.sin(angle) * R);			}			angle = -Math.PI / 2 + a;			g.lineTo(Math.cos(angle) * R, Math.sin(angle) * R);			g.lineTo(0, 0);			g.endFill();			endHand.rotation = angle * 180 / Math.PI;		}					}}