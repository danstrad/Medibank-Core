package med.infographic {	import com.gskinner.utils.Rndm;	import flash.display.Shape;	import flash.display.Sprite;	import flash.geom.Point;	public class ChapterSummaryWipe extends Sprite {				protected static const WIDTH:Number = 1024;		protected static const HEIGHT:Number = 576;		protected static const CENTRE_BOX_SIZE:Number = 200;				protected var wipeMask:Shape;		protected var _wipeProgress:Number;		protected var _durationProgress:Number;		public var source:String;				public var startTime:Number;		public var duration:Number;				protected var firstStart:Number;		protected var lastEnd:Number;				public function getScrollOffTime():Number { return firstStart; }				public var animationType:String;		protected var boxes:Vector.<Shape>;		protected var animTime:Number;				public function ChapterSummaryWipe() {			wipeMask = new Shape();			wipeMask.graphics.beginFill(0x0);			wipeMask.graphics.drawRect(0, 0, WIDTH, HEIGHT);			wipeMask.graphics.endFill();			addChild(wipeMask);			wipeMask.x = -WIDTH / 2;			wipeMask.y = -HEIGHT / 2;			wipeMask.visible = false;			mask = wipeMask;						boxes = new Vector.<Shape>();		}				public function drawColor(color:uint):void {			graphics.clear();			graphics.beginFill(color);			graphics.drawRect( -WIDTH / 2, -HEIGHT / 2, WIDTH, HEIGHT);			graphics.endFill();		}				public function get wipeProgress():Number { return _wipeProgress; }		public function set wipeProgress(value:Number):void {			_wipeProgress = value;			switch(source) {				default:				case "right":					wipeMask.width = WIDTH * _wipeProgress;					wipeMask.x = WIDTH * (0.5 - _wipeProgress);					break;				case "left":					wipeMask.width = WIDTH * _wipeProgress;					wipeMask.x = WIDTH * -0.5;					break;				case "bottom":					wipeMask.height = HEIGHT * _wipeProgress;					wipeMask.y = HEIGHT * (0.5 - _wipeProgress);					break;				case "top":					wipeMask.height = HEIGHT * _wipeProgress;					wipeMask.y = HEIGHT * -0.5;					break;			}		}				public function delayAnimation(time:Number):void {			animTime -= time;		}				public function initAnimation():void {			animTime = 0;			firstStart = duration;			lastEnd = 0;			var i:int;			var box:ChapterSummaryBox;			var box1:ChapterSummaryBox;			var box2:ChapterSummaryBox;			var box3:ChapterSummaryBox;			var box4:ChapterSummaryBox;			switch(animationType) {				case "floating":					Rndm.seed = 7;					const NUM_FLOATERS:int = 14;					for (i = 0; i < NUM_FLOATERS; i++) {						box = new ChapterSummaryBox();						box.visible = false;						addChildAt(box, 0);						boxes.push(box);												var floatX:Number = (i - (NUM_FLOATERS / 2)) / NUM_FLOATERS + ((Rndm.random() - 0.5) * 0.1);// (Rndm.random() - 0.5);						const MIN_X_FLOAT:Number = 0.05;						if (floatX > 0) floatX = MIN_X_FLOAT + (1 - MIN_X_FLOAT) * floatX;						else floatX = -MIN_X_FLOAT + (1 - MIN_X_FLOAT) * floatX;						box.dx = floatX * 2.3;						box.dy = (0.8 + Rndm.random() * 0.5) * -1.6;						box.alpha = 0.2 + Rndm.random() * 0.4;						box.start = new Point(floatX * 0.9 * CENTRE_BOX_SIZE, -CENTRE_BOX_SIZE * 0.45);						box.targetScale = 0.2 + Rndm.random() * 0.4;						var rot:Number = ((floatX >= 0) ? 1 : -1) * (0.8 + Rndm.random() * 0.7);						box.targetRotation = 500 * rot; // * floatX												box.startTime = 0.6 * Rndm.random() * duration;						box.endTime = box.startTime + 0.4 * duration;					}					break;									case "sprouting":					const SPROUT_SMALL:Number = 40;					const SPROUT_BIG:Number = 100;					var sproutEdge:Number = 100;					var sproutY:Number = 100 - SPROUT_SMALL / 2;					var big:Boolean = false;					var down:Boolean = true;					for (i = 0; sproutEdge < WIDTH / 2; i++) {						big = ((i % 2) == 1);						down = ((int((i + 2) / 4) % 2) == 0);						var size:Number = (big ? SPROUT_BIG : SPROUT_SMALL);						box1 = new ChapterSummaryBox();						box2 = new ChapterSummaryBox();						box1.start = new Point(sproutEdge + size / 2, sproutY);						box2.start = new Point(-sproutEdge - size / 2, -sproutY);						box1.targetScale = box2.targetScale = size / ChapterSummaryBox.SIZE;						box1.targetAlpha = box2.targetAlpha = (big ? 0.15 : 0.3);						box1.source = (down ? "tl" : "bl");						box2.source = (down ? "br" : "tr");												box1.visible = false;						box2.visible = false;						addChildAt(box1, 0);						addChildAt(box2, 0);						boxes.push(box1);						boxes.push(box2);												box1.startTime = box2.startTime = sproutEdge * 3;						box1.endTime = box2.endTime = box1.startTime + size * 2;						sproutEdge += size;						if (down) sproutY += SPROUT_BIG / 2;						else sproutY -= SPROUT_BIG / 2;					}					break;									case "sliding":					var slideEdge:Number = 100;					var slideSize:Number = 100;					var slideScale:Number = slideSize / ChapterSummaryBox.SIZE;					for (i = 0; slideEdge < WIDTH / 2; i++) {						box1 = new ChapterSummaryBox();						box2 = new ChapterSummaryBox();						box3 = new ChapterSummaryBox();						box4 = new ChapterSummaryBox();						box1.start = new Point(slideEdge + slideSize / 2, -slideSize / 2);						box2.start = new Point(slideEdge + slideSize / 2, slideSize / 2);						box3.start = new Point(-slideEdge - slideSize / 2, -slideSize / 2);						box4.start = new Point( -slideEdge - slideSize / 2, slideSize / 2);						box1.alpha = box3.alpha = (i % 2 == 0) ? 0.3 : 0.15;						box2.alpha = box4.alpha = (i % 2 == 1) ? 0.3 : 0.15;						box1.source = box2.source = "l";						box3.source = box4.source = "r";												for each(box in [box1, box2, box3, box4]) {							box.scaleX = box.scaleY = box.targetScale = slideScale;							box.visible = false;							addChildAt(box, 0);							boxes.push(box);													box.startTime = slideEdge * 2;							box.endTime = box.startTime + slideSize * 1.5;						}																		slideEdge += slideSize;					}										break;							}			for each(box in boxes) {				firstStart = Math.min(firstStart, box.startTime);				lastEnd = Math.max(lastEnd, box.endTime);			}			if (animationType == "sliding") {				var shift:Number = duration - lastEnd;				for each(box in boxes) {					box.startTime += shift;					box.endTime += shift;				}				firstStart += shift;				lastEnd += shift;			}		}				public function get durationProgress():Number { return _durationProgress; }		public function set durationProgress(value:Number):void {			_durationProgress = value;						animTime = duration * _durationProgress;			updateBoxes();		}						public function animate(dTime:Number):void {			/*			return;						animTime += dTime;						if (animTime < 0) return;						updateBoxes();			*/		}				protected function updateBoxes():void {			var box:ChapterSummaryBox;						switch(animationType) {				case "floating":					for each(box in boxes) box.floatingTime = animTime;					break;				case "sprouting":					for each(box in boxes) box.sproutingTime = animTime;					break;				case "sliding":					for each(box in boxes) box.slidingTime = animTime;					break;			}					}					}}